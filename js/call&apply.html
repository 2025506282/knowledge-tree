<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Call</title>
</head>
<body>
    <script>
        // context传入的上下文，this函数上下文
        Function.prototype.mycall = function(context) {
            if(typeof this !== 'function') {
                throw new Error('is not funciton')
            }
            context = context || window;
            context.fn = this;
            let args = [...arguments].slice(1);
            console.log('args', arguments);
            let result = context.fn(...args);
            delete context.fn;
            return result;
        }
         // context传入的上下文，this函数上下文
        Function.prototype.myapply = function(context) {
            if(typeof this !== 'function') {
                throw new Error('is not funciton')
            }
            context = context || window;
            context.fn = this;
            let result;
            if(arguments[1]) {
                result = context.fn(...arguments[1])
            } else {
                result = context.fn();
            }
            delete context.fn;
            return result;
        }
        // 从上述可以看出call和apply的区别，
        // 其实mycall函数其实是为传入的对象（或者叫做上下文）重新添加了（赋值）了一个新的方法
        var cat = {
            name: 'cat',
            speak: function() {
                console.log(this.name);
                console.log(arguments);
            }
        }
        var dog = {
            name: 'dog',
            speak: function(arr) {
                console.log(this.name);
                console.log(arguments);
            }
        }
        // cat.speak.mycall(dog, [2,3]);
        cat.speak.mycall(dog, [2,3]);
        cat.speak.myapply(dog, [2,3]);
    </script>
</body>
</html>